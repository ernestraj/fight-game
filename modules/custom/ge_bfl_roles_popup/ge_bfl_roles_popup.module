<?php

/**
 * @file
 * Define enhanced autocomplete widget.
 */

/**
 * Implements hook_menu().
 */
function ge_bfl_roles_popup_menu() {
  $items = array();

  $items['bfl_roles_popup/%ctools_js/%/%/%/%'] = array(
    'title' => 'Add BFL/Roles',
    'page callback' => 'bfl_roles_popup_page',
    'access callback' => TRUE,
    'page arguments' => array(1, 2, 3, 4, 5, 6),
    'type' => MENU_CALLBACK,
  );

  $items['ge_taxonomy_widget/autocomplete/%/%/%/%'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'ge_taxonomy_widget_taxonomy_autocomplete',
    'page arguments' => array(2, 3, 4, 5),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['get_child/%'] = array(
    'page callback' => '_get_child_taxonomy',
    'access arguments' => array('access content'),
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  $items['tree_with_ajax/%'] = array(
    'page callback' => '_draw_tree_with_ajax',
    'access arguments' => array('access content'),
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
 
  return $items;
}

/**
 * callback for bfl_roles_popup_page().
 */
function bfl_roles_popup_page($ajax, $field_label, $bfl_roles_view_name, $field_name, $field_html_id, $country_tid) {
  if ($ajax) {
    ctools_include('ajax');
    ctools_include('modal');
    ctools_include('plugins');
    ctools_modal_add_js();

    $form_state = array(
      'ajax' => TRUE,
      'field_label' => $field_label,
      'title' => t('BFL/Roles ' . $field_label . ' Form'),
      'bfl_roles_view_name'  => $bfl_roles_view_name,
      'field_html_id' => $field_html_id,
      'field_taxonomy_name'  => $field_name,
      'country' => _node_country_value(),
    );
    //IF $country_tid is passed in URL, set it in $form_state['country']
    if (isset($country_tid) && $country_tid != '') {
      $form_state['country'] = $country_tid;
    }
    // Use ctools to generate ajax instructions for the browser to create
    // a form in a modal popup.
    $output = ctools_modal_form_wrapper('ge_bfl_roles_popup_form', $form_state);

    // If the form has been submitted, there may be additional instructions
    // such as dismissing the modal popup.
    if (!empty($form_state['ajax_commands'])) {
      $output = $form_state['ajax_commands'];
    }

    // Return the ajax instructions to the browser via ajax_render().
    print ajax_render($output);
    drupal_exit();
  }
  else {
    return drupal_get_form('ge_bfl_roles_popup_form');
  }
}


/**
 * BFL/Roles form to be put in a modal.
 */
function ge_bfl_roles_popup_form($form, &$form_state) {
  $module_path = drupal_get_path('module', 'ge_bfl_roles_popup');
  $vocab_name = $form_state['field_taxonomy_name'];
  $range_vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
  $html = '';
  $options = array();
  if (strpos($range_vocab->machine_name, "bfl") !== false)
    $is_bfl = TRUE;
  else
    $is_bfl = FALSE; 

  if ($is_bfl) {
    drupal_add_library('system', 'jquery.cookie', TRUE);
    drupal_add_library('system', 'ui', TRUE);
    drupal_add_library('system', 'ui', TRUE);
    drupal_add_library('system', 'ui.widget', TRUE);
    $library_path = libraries_get_path('dynatree');
    $dynatree_file = $library_path . '/src/jquery.dynatree.min.js';
    if (!file_exists($dynatree_file)) {
      $dynatree_file = $library_path . '/dist/jquery.dynatree.min.js';
    }
    drupal_add_css($library_path. '/src/skin/ui.dynatree.css');
    drupal_add_js($dynatree_file);
    drupal_add_js($module_path . '/ge_bfl_roles_dynatree.js');
    $optionClass = '{"checkbox": "dynatree-checkbox"}';
    $vocab = taxonomy_get_tree($range_vocab->vid, 0, 1);
    $json = dynatree_widget_get_parents($vocab,$element);
    $json = drupal_json_encode($json);
     drupal_add_js(array("ge_bfl_roles_popup" => array('is_bfl' => $is_bfl, 'json' => $json, 'field_name' => $form_state['field_html_id'], 'vid'=>$range_vocab->vid, 'selection_type' => 3, 'skin_type' => 'skin-vista', 'check' => true, 'option_class' => $optionClass)), 'setting');
    $html = '<div id="tree"></div>';
    $options = _get_business_function_location($vocab_name);
  }
  else {
    $country = $form_state['country'];
    $viewname = $form_state['bfl_roles_view_name'];
    if (!empty($viewname)) {
      $target_view = explode('|', $viewname);
      $view = views_get_view($target_view[0]);
    }
    $global_country = _get_global_term_tid();
    $args = array();
    if (!empty($country)) {
      if ($country == $global_country) {
        $args[] = 'all';
      }
      else
        $args[] = $country;
    }
    if (!empty($view)) {
      $view->set_arguments(array(implode('+', $args)));
      $view->set_display($target_view[1]);
      $view->display_handler->set_option('use_ajax', TRUE);
      $view_markup = $view->preview();
      $html = '';

      // In case there's exposed widgets, put them at the top of the modal.
      if (!empty($view->exposed_widgets)) {
        $html .= '<div class="view-filters">' . $view->exposed_widgets . '</div>';
      }
      $html .= $view_markup;
    }
    $options = _get_roles_options($vocab_name);
    drupal_add_js(array("ge_bfl_roles_popup" => array('is_bfl' => $is_bfl,'field_name' => $form_state['field_html_id'])), 'setting');
  }
  
  $form = array();
  $form['selected_bfl'] = array(
    '#type' => 'select',
    '#title' => t('Selected ' . $form_state['field_label']),
    '#options' => $options,
    '#multiple' => TRUE,
    '#attributes' => array(
      'class' => array('chosen-widget'),
     ),
  );
  $form['tree'] = array(
    "#markup"=> $html,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
    '#weight' => 100,
  );
  return $form;
}

/**
 * Drupal form submit handler for ge_bfl_roles_popup_form
 */
function ge_bfl_roles_popup_form_submit($form, &$form_state) {
  $bfl_values = $form_state['values']['selected_bfl'];
  $field_html_id = '#' . $form_state['field_html_id'];
  $bfl_terms = taxonomy_term_load_multiple($bfl_values);

  $output = '';
  $vocab_name = $form_state['field_taxonomy_name'];
  $range_vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
  if (strpos($range_vocab->machine_name, "bfl") !== false) {
    foreach ($bfl_terms as $tax) {
      $output .= $tax->name . " (id:" . $tax->tid . ")" . ',';
    }
  }
  else {
     foreach ($bfl_terms as $tax) {
      $output .= $tax->name . ',';
    }
  }

  $ajax_commands = array();
  $ajax_commands[] = ctools_modal_command_dismiss();
  $ajax_commands[] = array(
      // Javascript command to fire on form submit
      'command' => 'submitBflRolesToForm',
      // We pass the field name and the image URL returned from the modal window.
      'selector' => $field_html_id,
      'selectedValue' => $output,
  );
  $form_state['ajax_commands'] = $ajax_commands;
}

/** 
 * Get Vocabulary Id
 * @param int $tid Term Id
 * @return Vocabulary Id, false if vid was not founded
 */
function _get_vid_value($tid = 0){
  if ( $tid == 0 )
    return false;
		
  $vid = FALSE;
  if ( $vid !== FALSE )
    return $vid->data;
	
  $result = db_query('
    SELECT t.vid 
    FROM {taxonomy_term_data} t
    WHERE t.tid = :tid', 
    array(":tid"=> $tid)
  );
	
  if ( $vid = $result->fetchField() ){
    return $vid;
  }
  else {
    return false;
  }
}

function _get_child_taxonomy($tid) {
  $json = '';
  $islazy = true;
  $select=true;
  $vid = _get_vid_value($tid);
  $childs = taxonomy_get_children($tid,$vid);	
  foreach ($childs as $child) {
    $result = array();    
    if ( empty($result) || in_array(TRUE,$result)){
      $hasChilds = taxonomy_get_children($child->tid,$vid);
      if (!empty($hasChilds)) {
        $json .= '{"key":"' . $child->tid . '","title":"' . $child->name . '","target":"_self", "isLazy":"'.$islazy.'", "isFolder" :"false","select":"true"},';
      } 
      else {
        $json .= '{"key":"' . $child->tid . '","title":"' . $child->name . '", "target":"_self", "select":"true"},';
      }
    }
  }
  $json = '[' . substr_replace($json, "", -1) . ']';
  $json = drupal_json_decode($json);
  drupal_json_output($json);
}

function _draw_tree_with_ajax($vid) {
  $json = '';
  $tree = array();

  if ($vid) {
    $vocab = taxonomy_get_tree($vid, 0, 1);
    $tree = dynatree_widget_get_parents($vocab,$element); 
	
	}
  return drupal_json_output($tree);
}

function _get_term_children($tid){
  if ($tid == 0 )
    return false;
  $children=taxonomy_get_children($tid, $vid = 0);
  return $children;
}

function dynatree_widget_get_parents($vocab, $element, &$tree = array(), $i = 0 ){
  $unselectable = false;
  foreach ($vocab as $key => $parent) {
    $result = array();
   
    if( empty($result) || in_array(TRUE,$result)){
      $isLazy = true;
      $isFolder = FALSE;
      $expand =  FALSE;
      $hideCheckbox=false;
      $child_children = taxonomy_get_children($parent->tid);
      $hasChilds = (empty($child_children))? FALSE: TRUE;
      $select = false;
      $isLazy = true;
      
      if($hasChilds){
	 $isFolder = true;
      }
      $hideCheckbox = false;
      $tree[$i] = array(
        'unselectable' => $unselectable,
        'hideCheckbox' => $hideCheckbox,
        'key' => $parent->tid,
        'target' => '_self',
        'href' => '',
        'title' => $parent->name,
        'select' => $select,
        'expand' => FALSE,
        'isLazy' => $isLazy,
	'isFolder' => $isFolder,
      );
      if ($expand) { // If Tree Type is diferent of  Lazy tree
         
          $childs = taxonomy_get_children($parent->tid);
	        }
        $tree[$i]['children'] = array();
	dynatree_widget_get_parents($childs, $element, $tree[$i]['children']);
      
    }
    $i++;
  }
  return $tree;
}

function _get_roles_options($vocab_name) {
  $range_vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
  $vid = $range_vocab->vid;
  $term_options_list = array();
  $efq = new EntityFieldQuery();
  $query = $efq->entityCondition('entity_type', 'taxonomy_term');
  $query->propertyCondition('vid', $vid);
  $country = taxonomy_term_load($_SESSION['country']);
  if($country->name != 'GBL')
    $query->fieldCondition('field_role_country', 'tid', $_SESSION['country'], '=');
  $query->propertyOrderBy('weight');
  $result = $query->execute();

  if(!empty($result['taxonomy_term'])) {
    $terms = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));
    foreach ($terms as $term) {
      // To hook into i18n and everything else, use entity_label().
      $term_options_list[$term->tid] = entity_label('taxonomy_term', $term);
    }
  }
  $safe_term_options_list = array_map('check_plain', $term_options_list);
  return $safe_term_options_list;
}

/* Function for loading BFL and values to chosen widget
 * @param type $field_type
 * @rerurn type $safe_term_options_list
 */
function _get_business_function_location($vocab_name) {
  $range_vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
  $vid = $range_vocab->vid;
  $term_options_list = array();
  $efq = new EntityFieldQuery();
  $result = $efq->entityCondition('entity_type', 'taxonomy_term')
          ->propertyCondition('vid', $vid)
          ->propertyOrderBy('weight')
          ->execute();

  if (!empty($result['taxonomy_term'])) {
    // The results contain an array of entity stubs keyed by {term}.tid.
    // The stub only has {term}.tid and vocabulary_machine_name.
    $first_term_stub = current($result['taxonomy_term']);
    $first_term_tid = key($result['taxonomy_term']);
    // To load all terms.
    $terms = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));
    // To generate an options list.
    foreach ($terms as $term) {
      // To hook into i18n and everything else, use entity_label().
      $term_options_list[$term->tid] = entity_label('taxonomy_term', $term);
      // Single language, no term label alters.
      $term_options_list[$term->tid] = $term->name;
    }
  }
  // IMPORTANT. This was for a select list that expects raw values.
  // If ANYTHING else is required, escape the term names, either here
  // or where the name is used.
  $safe_term_options_list = array_map('check_plain', $term_options_list);
  return $safe_term_options_list;
}


/**
 * Implements hook_form_alter().
 */
function ge_bfl_roles_popup_form_alter(&$form, &$form_state, $form_id) {
  if (substr($form_id, -9) == 'node_form' && $form_id != 'project_node_form') {
    $form['#after_build'][] = '_modal_bfl_add_js';
    $form['#attached']['js'][] = drupal_get_path('module', 'ge_bfl_roles_popup') . '/js/ge_bfl_roles_popup.js';
  }
}

/**
 * Function for adding ctools plugins
 * @param type $form_element
 * @param type $form_state
 * @return type $form_element
 */
function _modal_bfl_add_js($form_element, &$form_state) {
  ctools_include('modal');
  ctools_modal_add_js();
  return $form_element;
}


/**
 * Implements hook_form_ID_alter().
 */
function ge_bfl_roles_popup_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  $instance = $form['#instance'];
  
  if ($form['#field']['type'] == 'taxonomy_term_reference') {
    $viws_list = views_get_all_views();
    $options = array();
    foreach ($viws_list as $view) {
      //Fiilter disabled views from the list as we don't want to show them
      if(!isset($view->disabled)) {
        //list($view, $display_id) = $data;
        $view_name = !empty($view->human_name) ? $view->human_name : $view->name;
        $temp = array();
        //Create fieldgroup with view_name for each display type
        foreach($view->display as $key=> $display_type) {
          //$options[$view->name . '|' . $key] = check_plain($view_name . ' | ' . $display_type->display_title);
          $temp[$view->name . '|' . $key]  = check_plain($view_name . ' | ' . $display_type->display_title);
        }

        $options[$view->name] = $temp;
      }
    }
    $form['instance']['widget']['settings']['autocomplete'] = array(
      '#type' => 'fieldset',
      '#title' => t('BFL/Roles Pop-up settings'),
    );

    $form['instance']['widget']['settings']['autocomplete']['show_popup'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show BFL/Roles Pop-up'),
      '#default_value' => isset($instance['widget']['settings']['autocomplete']['show_popup']) ? $instance['widget']['settings']['autocomplete']['show_popup'] : 0,
    );
    $form['instance']['widget']['settings']['autocomplete']['bfl_roles_view'] = array(
      '#type' => 'select',
      '#title' => t('View Used to create BFL/Roles Pop-up'),
      '#options' => $options,
      '#default_value' => isset($instance['widget']['settings']['autocomplete']['bfl_roles_view']) ? $instance['widget']['settings']['autocomplete']['bfl_roles_view'] : 'select',
      '#description' => t('Select the view which will be rendered for showing the BFL/Roles pop-up.'),
      '#states' => array(
        'visible' => array(// action to take.
          ':input[name="instance[widget][settings][autocomplete][show_popup]"]' => array('checked' => TRUE),
        ),
        'required' => array(
          ':input[name="instance[widget][settings][autocomplete][show_popup]"]' => array('checked' => TRUE),
        ),
      ),
    );
    $form['instance']['widget']['settings']['autocomplete']['filter_by_country'] = array(
      '#type' => 'checkbox',
      '#title' => t('Filter View results by country'),
      '#description' => t('Using this widget will limit terms in form according to session country or country which node belongs to'),
      '#default_value' => isset($instance['widget']['settings']['autocomplete']['filter_by_country']) ? $instance['widget']['settings']['autocomplete']['filter_by_country'] : FALSE,
    );
    $form['instance']['widget']['settings']['autocomplete']['deny_new_terms'] = array(
      '#type' => 'checkbox',
      '#title' => t('Deny  New Terms'),
      '#description' => t('Check this box if you want to deny adding new terms in this field'),
      '#default_value' => isset($instance['widget']['settings']['autocomplete']['deny_new_terms']) ? $instance['widget']['settings']['autocomplete']['deny_new_terms'] : FALSE,
    );
    $form['instance']['use_ge_taxonomy_widget'] = array(
      '#type' => 'checkbox',
      '#title' => t('GE Taxonomy Widget'),
      '#description' => t('Using this widget will limit terms in form according to session country or country which node belongs to'),
      '#default_value' => isset($instance['use_ge_taxonomy_widget']) ? $instance['use_ge_taxonomy_widget'] : FALSE,
    );
    $form['instance']['ge_taxonomy_country_field'] = array(
      '#type' => 'textfield',
      '#title' => t('Vocabulary field for country'),
      '#description' => t('Provide machine name for vocabulary country field to use.'),
      '#default_value' => isset($instance['ge_taxonomy_country_field']) ? $instance['ge_taxonomy_country_field'] : '',
    );
  }
}

/**
 * Implements hook_field_attach_form
 * @param type $entity_type
 * @param type $entity
 * @param string $form
 * @param type $form_state
 * @param type $langcode
 */
function ge_bfl_roles_popup_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Determine the list of instances to iterate on.
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $instances = field_info_instances($entity_type, $bundle);
  foreach ($instances as $field_name => $instance) {
    $lang_key = $form[$instance['field_name']]['#language'];
    if (($instance['widget']['type'] == 'taxonomy_autocomplete' || $instance['widget']['type'] == "term_ref_autocomplete_widget") 
      && ($instance['widget']['settings']['autocomplete']['show_popup'] == 1)) {
      $field = field_info_field($field_name);
      $field_vocabulary = $field['settings']['allowed_values'][0]['vocabulary'];
      $form_state[$field_name][$instance['bundle']]['bfl_roles_view_name'] = $instance['widget']['settings']['autocomplete']['bfl_roles_view'];
      $form_state[$field_name][$instance['bundle']]['filter_by_country'] = $instance['widget']['settings']['autocomplete']['filter_by_country'];
      $form_state[$field_name][$instance['bundle']]['field_vocabulary'] = $field_vocabulary;
      $form[$instance['field_name']][$lang_key]['#after_build'][] = '_ge_bfl_roles_widget_add_desc';
    }
    //If condition for Taxonomy Widget && $instance['field_name'] == 'field_self_service_roles'
    if (($instance['widget']['type'] == 'taxonomy_autocomplete' || $instance['widget']['type'] == 'autocomplete_deluxe_taxonomy'
         || $instance['widget']['type'] == "term_ref_autocomplete_widget") && $instance['widget']['settings']['autocomplete']['deny_new_terms']) {
      $form[$instance['field_name']][$lang_key]['#element_validate'][] = 'ge_taxonomy_widget_validate_deny_new_terms';
    }
  }
}

/**
 * Function to add #description for each Form Element.
 * @param array $element
 * @param type $form_state
 * @return type array $element
 */
function _ge_bfl_roles_widget_add_desc($element, &$form_state) {
  $url_element = array();
  $view_name = $form_state[$element['#field_name']][$element['#bundle']]['bfl_roles_view_name'];
  $field_vocabulary = $form_state[$element['#field_name']][$element['#bundle']]['field_vocabulary'];
  if($form_state[$element['#field_name']][$element['#bundle']]['filter_by_country']) {
    $nid = $form['nid']['#value'];
    if (is_null($nid)) {
      $country = $_SESSION['country'];
    }
    else {
      $country = $form['field_country']['und']['#default_value'][0];
    }
  }

  $url_element[] = 'bfl_roles_popup';
  $url_element[] = 'nojs';
  $url_element[] = $element['#title'];
  $url_element[] = $view_name;
  $url_element[] = $field_vocabulary;
  $url_element[] = $element['#id'];
  if($country) {
    $url_element[] = $country;
  }
  //Generate Full URL 
  $full_pop_url = implode('/', $url_element);
  //Add description to element
  $element['#description'] = l($element['#title'], $full_pop_url , array('attributes' => array('class' => 'ctools-use-modal ctools-search-icon')));
  return $element;
}

/**
 * Form element validate handler for taxonomy term autocomplete element, 
 * which denies any new terms removes extra terms in the field 
 */
function ge_taxonomy_widget_validate_deny_new_terms($element, &$form_state, $form) {
  $country_field = $element['#instance']['ge_taxonomy_country_field'];
  $parents = $element['#array_parents'];
  $values = $form_state['values'];
  // get country of node
  $node_country = _node_country_value();
  $global_country = _get_global_term_tid();
  foreach ($element['#array_parents'] as $parent) {
    $values = $values[$parent];
  }
  foreach ($values as $delta => $value) {
    if ($value['tid'] == 'autocreate')
      form_error($element, t('%name: new terms are not allowed. Please choose from the given list. Removed roles %value in the list', array('%name' => $element['#title'], '%value' => $value['name'])));
    elseif (isset($value[$country_field]) && $node_country != $global_country && $value[$country_field]['und'][0]['tid'] != $node_country) {
      $term = taxonomy_term_load($value[$element['#instance']['ge_taxonomy_country_field']]['und'][0]['tid']);
      form_error($element, t('%name: Removed roles %value in the list which belongs to %country', array('%name' => $element['#title'], '%value' => $value['name'], '%country' => $term->name)));
    }
  }
  if ($element['#field_name'] == "field_self_service_roles")
    $validated_roles = _remove_extra_role($country_field, $form, $form_state, $node_country, $parents);
  else
    $validated_roles = _remove_extra_bfl_role($form, $form_state, $parents);
  
  $parents = $element['#array_parents'];
  if ($element['#bundle'] == "field_section")
    $form['field_group'][LANGUAGE_NONE][$parents[2]]['field_section'][LANGUAGE_NONE][$parents[5]][$parents[6]][LANGUAGE_NONE]['#value'] = $validated_roles;
  elseif ($element['#bundle'] == "field_link_type_new")
    $form['field_group'][LANGUAGE_NONE][$parents[2]]['field_section'][LANGUAGE_NONE][$parents[5]]['field_link_type_new'][LANGUAGE_NONE][$parents[8]][$parents[9]][LANGUAGE_NONE]['#value'] = $validated_roles;
  elseif ($element['#bundle'] == "field_group" || $element['#bundle'] == 'field_files')
    $form[$element['#bundle']][LANGUAGE_NONE][$parents[2]][$parents[3]][LANGUAGE_NONE]['#value'] = $validated_roles;
  elseif ($element['#bundle'] == "add_page" || $element['#bundle'] == "link_to_a_document")
    $form[$parents[0]][LANGUAGE_NONE]['#value'] = $validated_roles;
}

/**
 * Return valid list of roles for a particular node.
 */
function _remove_extra_role($country_field, $form, $form_state, $node_country, $tree) {
  $validated_roles = '';
  $values = $form_state['values'];
  foreach ($tree as $parent) {
    $values = $values[$parent];
  }
  foreach ($values as $item) {
    if ($item['tid'] != 'autocreate') {
      $term = (array) taxonomy_term_load($item['tid']);
      if (isset($term[$country_field]) && $term[$country_field]['und'][0]['tid'] == $node_country)
        $validated_roles .= $item['name'] . ",";
    }
  }
  return $validated_roles;
}

/**
 * Returns valid list fo terms for bfl fields
 */
function _remove_extra_bfl_role($form, $form_state, $tree) {
  $validated_roles = '';
  $values = $form_state['values'];
  foreach ($tree as $parent) {
    $values = $values[$parent];
  }
  foreach ($values as $item) {
    if ($item['tid'] != 'autocreate') {
      $term = (array) taxonomy_term_load($item['tid']);
      $validated_roles .= $item['name'].'(id:'.$item['tid'].')' . ",";
    }
  }
  return $validated_roles;
}

/**
 * Returns $global_country_tid
 */
function _get_global_term_tid() {
  $global_country_tid = variable_get('global_country_tid');
  if (!isset($global_country_tid)) {
    $taxs = taxonomy_get_term_by_name('GBL', 'country');
    if (!empty($taxs)) {
      foreach ($taxs as $tax) {
        $global_country_tid = $tax->tid;
      }
    }
  }
  return $global_country_tid;
}

/**
 * Implements hook_field_widget_form_alter
 */
function ge_bfl_roles_popup_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['type'] == 'taxonomy_term_reference' && isset($context['instance']['use_ge_taxonomy_widget'])
          && $context['instance']['use_ge_taxonomy_widget']) {
    if (isset($element['#type']) && ($element['#type'] == 'select' || $element['#type'] == 'radios' || $element['#type'] == 'checkboxes')) {
      $field = field_info_field($element['#field_name']);
      $instance = field_info_instance($context['instance']['entity_type'], $element['#field_name'], $context['instance']['bundle']);
      $country = _node_country_value();
      $global_country = _get_global_term_tid();

      $field_vocabulary = $field['settings']['allowed_values'][0]['vocabulary'];
      $country_field = $instance['ge_taxonomy_country_field'];
      if ($country != $global_country)
        $allowed = _get_term_ids($country, NULL, $field_vocabulary, $country_field, $element['#type']);
      else
        $allowed = _get_term_ids($country, NULL, $field_vocabulary, $country_field, $element['#type'], TRUE);
      if (!empty($allowed)) {
        $options = array();
        if (isset($element['#options']['_none'])) {
          $options = array('_none' => $element['#options']['_none']);
        } else {
          $options = array('_none' => theme('options_none', array('instance' => $context['instance'], 'option' => $element['#properties']['empty_option'])));
        }
        $element['#options'] = $allowed;
      } 
      else {
        $options = array();
        if (isset($element['#options']['_none']))
          $options = array('_none' => $element['#options']['_none']);
        $element['#options'] = $options;
      }
    } 
    elseif (isset($element['#autocomplete_path']) || isset($element['tid']['#autocomplete_path'])) {
      if (isset($element['#field_name'])) {
        $element['#instance'] = $context['instance'];
        if ($element['#field_name'] != "field_self_service_roles")
          foreach ($context['items'] as $item) {
            $tids[$item['tid']] = $item['tid'];
          }
        $vocabulary = $context['field']['settings']['allowed_values'][0]['vocabulary'];
        if(strpos($vocabulary, "bfl") !== false) {
          $referencable_terms = _get_referencable_terms_from_custom($context['field'], $context['instance'], NULL, 0, $tids);
          $element['#default_value'] = implode(',', $referencable_terms);
          $element['#element_validate'][] = '_ge_taxonomy_widget_autocomplete_validate';
	}
        $element['#autocomplete_path'] = 'ge_taxonomy_widget/autocomplete/' . $element['#field_name'] . '/' . $context['instance']['entity_type'] . '/' . $context['instance']['bundle'] . '/' . arg(1) . '/';	
      }
      // for Reference Dialog widget
      elseif (isset($element['tid']['#field_name'])) {
        $element['tid']['#instance'] = $context['instance'];
        if (!empty($element['tid']['#default_value'])) {
          $allowed_term = _get_term_ids($_SESSION['country'], array($element['tid']['#default_value']));
          $element['tid']['#default_value'] = current($allowed_term);
        }
        if (!empty($context['instance']['view']['size'])) {
          $element['tid']['#size'] = $context['instance']['view']['size'];
        }
        $element['tid']['#element_validate'] = array('_ge_taxonomy_widget_autocomplete_validate');
        $element['tid']['#autocomplete_path'] = 'ge_taxonomy_widget/autocomplete/' . $element['tid']['#field_name'] . '/' . $context['instance']['entity_type'] . '/' . $context['instance']['bundle'] . '/';
      }
    }
  }
}
/**
 * Get the TermsImplements hook_views_plugins_alter().
 */
function _get_referencable_terms_from_custom($field, $instance, $match = NULL, $limit = 0, $ids = NULL, $width_tid = TRUE) {
  $terms = array();
  $view_terms = taxonomy_term_load_multiple($ids);
  foreach ($view_terms as  $term) {
    // Strip things like starting/trailing white spaces, line breaks and tags.
    $terms[$term->tid] = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(decode_entities(strip_tags($term->name)))));
    if ($width_tid) {
      $terms[$term->tid] .= "(id:$term->tid)";
    }
  }
  return $terms;
}
/**
* Autocomplete callback for widgets that has autocomplete.
*/
function ge_taxonomy_widget_taxonomy_autocomplete($field_name, $entity_type, $bundle_name, $argument, $tid = '', $string = '') {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);
  $matches = array();
  $type = 'tags';
  if (!$field || !$instance || $field['type'] != 'taxonomy_term_reference' || !field_access('edit', $field, $entity_type)) {
    return MENU_ACCESS_DENIED;
  }

  $term = NULL;
  if ($tid !== 'NULL' && is_numeric($tid)) {
    $term = entity_load_single('taxonomy_term', $tid);
    if (!$term || !entity_access('view', 'taxonomy_term', $term)) {
      return MENU_ACCESS_DENIED;
    }
  }

  if ($type == 'tags') {
// The user enters a comma-separated list of tags. We only autocomplete the last tag.
    $tags_typed = drupal_explode_tags($string);
    $tag_last = drupal_strtolower(array_pop($tags_typed));
    if (!empty($tag_last)) {
      $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';
    }
  } else {
// The user enters a single tag.
    $prefix = '';
    $tag_last = $string;
  }

  if (!empty($tag_last)) {
    // Get an array of matching entities.
    $vocabulary = $field['settings']['allowed_values'][0]['vocabulary'];
    $term_labels = _get_referencable_terms($field, $instance, $tag_last, 15, $argument, NULL, FALSE);
    // Loop through the products and convert them into autocomplete output.
    foreach ($term_labels as $tid => $label) {
      if (strpos($vocabulary, "bfl") !== false)
        $key = "$label (id:$tid)";
      else
        $key = "$label";
      // Names containing commas or quotes must be wrapped in quotes.
      if (strpos($key, ',') !== FALSE || strpos($key, '"') !== FALSE) {
        $key = '"' . str_replace('"', '""', $key) . '"';
      }
      $matches[$prefix . $key] = $key;
    }
  }

  drupal_json_output($matches);
}

/**
 * Get the referencable Terms
 */
function _get_referencable_terms($field, $instance, $match = NULL, $limit = 0, $argument, $ids = NULL, $width_tid = TRUE) {
  $terms = array();
  $vocabulary = $field['settings']['allowed_values'][0]['vocabulary'];
  $view_terms = _get_results_for_term_reference_field($field, $instance, $match, $limit, $argument, $ids);
  foreach ($view_terms as $tid => $row) {
// Strip things like starting/trailing white spaces, line breaks and tags
    $terms[$tid] = preg_replace('/\s\s+/', ' ', str_replace("\n", '', trim(decode_entities(strip_tags($row)))));
    if ($width_tid) {
      $terms[$tid] .= " (id:$tid)";
    }
  }
  return $terms;
}

/**
 * Get the Terms
 */
function _get_results_for_term_reference_field($field, $instance, $match = NULL, $limit = 0, $argument, $ids = NULL) {
  $country = _node_country_value($argument);
// Get the results.
  $vocabulary = $field['settings']['allowed_values'][0]['vocabulary'];
  $vocabulary_field = $instance['ge_taxonomy_country_field'];
  $country = _node_country_value();
  $global_country = _get_global_term_tid();

  if (strpos($vocabulary, "bfl") !== false)
    $result = _get_term_ids($country, $match, $vocabulary, $vocabulary_field, "autocomplete", TRUE, TRUE);
  elseif ($country != $global_country)
    $result = _get_term_ids($country, $match, $vocabulary, $vocabulary_field, "autocomplete", FALSE, FALSE);
  else
    $result = _get_term_ids($country, $match, $vocabulary, $vocabulary_field, "autocomplete", TRUE, FALSE);
  return $result;
}

/**
 * Get terms from entity query.
 */
function _get_term_ids($country, $match = NULL, $vocabulary, $vocabulary_field, $widget, $global = FALSE, $bfl = FALSE) {
  $term_array = array();
  if (!empty($vocabulary) && (!empty($vocabulary_field) || $bfl)) {
    $tid_voc = taxonomy_vocabulary_machine_name_load($vocabulary);
    $taxonomnyquery = new EntityFieldQuery();
    if (!empty($country)) {
      $query = $taxonomnyquery->entityCondition('entity_type', 'taxonomy_term');
      $query->propertyCondition('vid', $tid_voc->vid);
      if ($widget == "autocomplete")
        $query->propertyCondition('name', $match, 'STARTS_WITH');
      if (!$global)
        $query->fieldCondition($vocabulary_field, 'tid', $country, '=');
      $query->propertyOrderBy('weight');
      if ($widget == "autocomplete")
        $query->range(0, 3);
      $terms = $query->execute();
    }
    
    if(isset($terms['taxonomy_term'])) {
      foreach ($terms['taxonomy_term'] as $item) {
        $term = taxonomy_term_load($item->tid);
        $term_array[$item->tid] = $term->name;
      }
    }
  }
  return $term_array;
}

/**
* Return country information of node
*/
function _node_country_value() {
  $node = menu_get_object();
  $country = $_SESSION['country'];
  if (isset($node))
    $country = $node->field_country['und'][0]['tid'];
  return $country;  
}

/**
 * Validation function for automplete function.
 */
function _ge_taxonomy_widget_autocomplete_validate($element, &$form_state, $form) {

  // If a value was entered into the autocomplete...
  $value = '';
  if (!empty($element['#value'])) {
    if ($element['#type'] == 'textfield') {
      $terms_data = drupal_explode_tags($element['#value']);
    }
    else {
      $terms_data = array($element['#value']);
    }
	
    foreach ($terms_data as $term_data) {
      // Take "label (term id)', match the id from parenthesis.
      if (preg_match("/.+\(\s*id\s*:(\d+)\)/", $term_data, $matches)) {
        if ($element['#instance']['widget']['type'] == 'references_dialog_term_reference') {
          $value = $matches[1];
        }
        else {
          $value[] = (array) taxonomy_term_load($matches[1]);
        }
      }
      else {
        $value[] = NULL;
      }
    }
  }
  if($value!=NULL){
  // Update the value of this element so the field can validate the product IDs.
  form_set_value($element, $value, $form_state);
  }
}
